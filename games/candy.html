<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Sweet Candy Rush ‚Äî AsiaTiger</title>
<link rel="icon" href="../logo.png"/>
<style>
  :root{
    --bg:#071827; --card:#0b1220; --accent:#ffb86b; --muted:#9aa4b2;
    --glass: rgba(255,255,255,0.03);
    color-scheme:dark;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071021 0%,#071827 100%);color:#e6eef6}
  .wrap{max-width:980px;margin:18px auto;padding:18px}
  header{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
  header h1{margin:0;font-size:20px}
  .meta{margin-left:auto;text-align:right;color:var(--muted)}
  .panel{background:var(--card);padding:14px;border-radius:12px;border:1px solid var(--glass);margin-top:12px}
  .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:center}
  .bet-input{width:110px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit;text-align:center}
  .btn{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700;background:linear-gradient(180deg,#ffb86b,#ff9f43);color:#000}
  .btn.secondary{background:transparent;border:1px solid var(--glass);color:var(--accent);font-weight:600}
  .grid-wrap{display:flex;justify-content:center;margin-top:14px}
  .grid{display:grid;grid-template-columns:repeat(6,54px);gap:8px;padding:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px}
  .cell{width:54px;height:54px;border-radius:8px;background:#0b1220;display:flex;align-items:center;justify-content:center;font-size:20px;box-shadow:0 2px 0 rgba(255,255,255,0.02)}
  .status{margin-top:12px;text-align:center;color:var(--muted)}
  .payline{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:10px}
  .small{padding:6px 8px;border-radius:8px;border:1px solid var(--glass);background:transparent;color:var(--muted)}
  .bottom-bar{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-top:16px;flex-wrap:wrap}
  .auto-controls{display:flex;gap:8px;align-items:center}
  .result{font-weight:800;text-align:center;margin-top:8px}
  .muted{color:var(--muted)}
  @media(max-width:600px){
    .grid{transform:scale(0.88);transform-origin:center}
    .controls{flex-direction:column}
    header{padding-bottom:8px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Sweet Candy Rush</h1>
      <div class="meta">
        <div id="balanceDisplay">Balance: ‚Äî</div>
        <div id="tgidDisplay" class="muted">TGID: ‚Äî</div>
      </div>
    </header>

    <div class="panel">
      <div class="controls">
        <div>
          <label class="muted">Bet</label><br/>
          <input id="betInput" class="bet-input" type="number" min="100" max="3000" step="100" value="200"/>
        </div>

        <div style="text-align:center">
          <div class="muted">Auto-spin</div>
          <div class="auto-controls">
            <button class="small btn secondary" id="auto10">10</button>
            <button class="small btn secondary" id="auto50">50</button>
            <button class="small btn secondary" id="auto100">100</button>
            <button class="small btn secondary" id="autoInf">‚àû</button>
            <button class="small btn secondary" id="stopAuto" style="display:none">Stop</button>
          </div>
        </div>

        <div style="text-align:center">
          <div class="muted">Scatter</div>
          <div id="scatterInfo" class="small">Match 4+ adjacent cells</div>
        </div>

        <div style="margin-left:auto">
          <button id="spinBtn" class="btn">SPIN</button>
        </div>
      </div>

      <div class="grid-wrap">
        <div id="grid" class="grid" aria-hidden="false"></div>
      </div>

      <div class="payline" id="paytable"></div>

      <div class="result" id="resultText">Good luck ‚Äî server decides outcome.</div>
      <div class="status" id="statusText"></div>
    </div>
  </div>

  <audio id="spinSound" src="../sounds/spin.mp3" preload="auto"></audio>
  <audio id="winSound" src="../sounds/win.mp3" preload="auto"></audio>

  <script type="module">
  // Candy game ‚Äî module
  // Uses /api/getBalance?tgid=... and /api/spin for server balance update
  (function(){
    // --- config ---
    const symbols = ['üç¨','üç≠','üç´','üç™','üçì','üçá'];
    const payouts = {'üç¨':8,'üç≠':6,'üç´':10,'üç™':5,'üçì':12,'üçá':7};
    const ROWS = 6, COLS = 6;

    // --- elements ---
    const gridEl = document.getElementById('grid');
    const betInput = document.getElementById('betInput');
    const spinBtn = document.getElementById('spinBtn');
    const balanceEl = document.getElementById('balanceDisplay');
    const tgidEl = document.getElementById('tgidDisplay');
    const resultText = document.getElementById('resultText');
    const statusText = document.getElementById('statusText');
    const paytable = document.getElementById('paytable');
    const spinSound = document.getElementById('spinSound');
    const winSound = document.getElementById('winSound');

    const auto10 = document.getElementById('auto10');
    const auto50 = document.getElementById('auto50');
    const auto100 = document.getElementById('auto100');
    const autoInf = document.getElementById('autoInf');
    const stopAuto = document.getElementById('stopAuto');

    // state
    let tgid = null; // can come from ?tgid= or demo set
    let vip = 'Bronze';
    let balance = 0;
    let autoRunning = false;
    let autoRemaining = 0;
    let autoUnlimited = false;
    let autoAbort = false;

    // --- helpers ---
    function getTgidFromUrl(){
      try{
        const p = new URLSearchParams(location.search);
        const v = p.get('tgid');
        return v && v.trim() ? v.trim() : null;
      }catch(e){return null;}
    }

    function vipRtpMultiplier(v){
      if(!v) return 1;
      v = String(v).toLowerCase();
      if(v.includes('platinum')) return 1.18;
      if(v.includes('gold')) return 1.12;
      if(v.includes('silver')) return 1.06;
      return 1;
    }

    function renderGrid(matrix){
      gridEl.innerHTML = '';
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const d = document.createElement('div');
          d.className = 'cell';
          d.textContent = matrix?.[r]?.[c] ?? '‚ùì';
          gridEl.appendChild(d);
        }
      }
    }

    function genGrid(){
      const g = Array.from({length:ROWS},()=>Array(COLS).fill(null));
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          g[r][c] = symbols[Math.floor(Math.random()*symbols.length)];
        }
      }
      return g;
    }

    // cluster detection (4+ orthogonally connected)
    function findClusters(grid){
      const R=ROWS, C=COLS;
      const seen = Array.from({length:R},()=>Array(C).fill(false));
      const clusters = [];
      function dfs(r,c,sym,acc){
        if(r<0||c<0||r>=R||c>=C) return;
        if(seen[r][c]) return;
        if(grid[r][c] !== sym) return;
        seen[r][c] = true;
        acc.push([r,c]);
        dfs(r+1,c,sym,acc);
        dfs(r-1,c,sym,acc);
        dfs(r,c+1,sym,acc);
        dfs(r,c-1,sym,acc);
      }
      for(let r=0;r<R;r++){
        for(let c=0;c<C;c++){
          if(!seen[r][c]){
            const acc = [];
            dfs(r,c,grid[r][c],acc);
            if(acc.length >= 4) clusters.push({sym: grid[r][c], size: acc.length, cells: acc});
          }
        }
      }
      return clusters;
    }

    function calcClusterPayouts(clusters){
      let total = 0;
      clusters.forEach(cl=>{
        const base = payouts[cl.sym] || 0;
        total += base * cl.size;
      });
      return total;
    }

    // visual paytable
    function renderPaytable(){
      paytable.innerHTML = '';
      Object.entries(payouts).forEach(([sym,v])=>{
        const d = document.createElement('div');
        d.className='small';
        d.textContent = `${sym} => ${v} √ó size`;
        paytable.appendChild(d);
      });
    }
    renderPaytable();

    // --- balance / server functions ---
    async function fetchBalanceFor(t){
      try {
        const res = await fetch('/api/getBalance?tgid=' + encodeURIComponent(t));
        if(!res.ok) throw new Error('no');
        const j = await res.json();
        return j;
      } catch(e){
        return null;
      }
    }

    async function refreshBalanceUI(){
      if(!tgid){
        const urlT = getTgidFromUrl();
        if(urlT) tgid = urlT;
      }
      if(!tgid){
        balance = 0;
        vip = 'Bronze';
        balanceEl.textContent = 'Balance: ‚Äî';
        tgidEl.textContent = 'TGID: ‚Äî';
        return;
      }
      tgidEl.textContent = 'TGID: ' + tgid;
      try{
        const j = await fetchBalanceFor(tgid);
        if(j && typeof j.balance !== 'undefined'){
          balance = Number(j.balance || 0);
          vip = j.vip_tier || vip;
          balanceEl.textContent = 'Balance: ' + balance;
        } else {
          // fallback: try reading minimal
          balanceEl.textContent = 'Balance: ' + balance;
        }
      }catch(e){
        balanceEl.textContent = 'Balance: ' + balance;
      }
    }

    async function serverSpinRequest(bet){
      // call /api/spin expecting json response
      try{
        const resp = await fetch('/api/spin', {
          method: 'POST',
          headers: {'Content-Type':'application/json','Authorization':'Bearer ' + tgid},
          body: JSON.stringify({ tgid, game: 'slot-candy', bet })
        });
        const data = await resp.json();
        if(!resp.ok) throw new Error(data?.error || 'spin failed');
        return data;
      } catch(e){
        console.warn('serverSpinRequest failed', e);
        return null;
      }
    }

    // --- spin flow ---
    async function singleSpin(bet){
      if(!tgid){
        resultText.textContent = 'Please login or add ?tgid=ID';
        return {ok:false};
      }
      if(bet > balance){
        resultText.textContent = 'Insufficient balance';
        return {ok:false};
      }

      // play spin sound
      try{ spinSound.currentTime = 0; spinSound.play(); }catch(e){}

      // local animation: generate grid + show quick spins
      const animCount = 6;
      for(let i=0;i<animCount;i++){
        renderGrid(genGrid());
        await new Promise(r=>setTimeout(r, 80 + i*15));
      }

      // ask server
      const serverResp = await serverSpinRequest(bet);
      let usedGrid, winAmount, newBal;
      if(serverResp && serverResp.reels && Array.isArray(serverResp.reels) && serverResp.reels.length >= 1){
        // server returned something (maybe not full grid). We'll use local cluster detection on local grid for fairness
        usedGrid = genGrid(); // server doesn't give full cluster grid; still update using cluster algorithm locally for demo
        winAmount = Number(serverResp.payout || serverResp.win || 0);
        newBal = Number(serverResp.new_balance ?? (balance - bet + winAmount));
      } else {
        // fallback: local computation
        usedGrid = genGrid();
        const clusters = findClusters(usedGrid);
        const baseWin = calcClusterPayouts(clusters);
        const mult = vipRtpMultiplier(vip);
        winAmount = Math.floor(baseWin * mult);
        newBal = balance - bet + winAmount;
      }

      renderGrid(usedGrid);
      balance = Number(newBal);
      balanceEl.textContent = 'Balance: ' + balance;

      // compute clusters & message
      const clusters = findClusters(usedGrid);
      if(clusters.length){
        const winMsg = clusters.map(c => `${c.sym}√ó${c.size}`).join(', ');
        resultText.textContent = `üéâ Win ${winAmount} ‚Äî ${winMsg}`;
        try{ winSound.currentTime = 0; winSound.play(); }catch(e){}
      } else {
        resultText.textContent = `‚Äî No win`;
      }

      statusText.textContent = `Last: ${new Date().toLocaleTimeString()}`;
      return {ok:true, win:winAmount};
    }

    // --- auto-spin ---
    async function runAuto(times){
      if(autoRunning) return;
      autoRunning = true;
      autoRemaining = times;
      autoUnlimited = times === Infinity;
      stopAuto.style.display = 'inline-block';
      let cnt = 0;
      while(autoRunning){
        if(!autoUnlimited && autoRemaining <= 0) break;
        if(autoAbort) break;
        const bet = Number(betInput.value || 0);
        const r = await singleSpin(bet);
        cnt++;
        if(!r.ok) { autoRunning=false; break; }
        if(!autoUnlimited) autoRemaining--;
        // short delay to avoid API throttling
        await new Promise(r=>setTimeout(r, 250));
      }
      autoRunning = false;
      autoAbort = false;
      stopAuto.style.display = 'none';
    }

    // --- UI wiring ---
    spinBtn.addEventListener('click', async ()=> {
      if(!tgid){ tgid = getTgidFromUrl() || null; if(!tgid){ alert('Login required or add ?tgid=your_id'); return; } }
      const bet = Number(betInput.value||0);
      await singleSpin(bet);
    });

    auto10.addEventListener('click', ()=> runAuto(10));
    auto50.addEventListener('click', ()=> runAuto(50));
    auto100.addEventListener('click', ()=> runAuto(100));
    autoInf.addEventListener('click', ()=> runAuto(Infinity));
    stopAuto.addEventListener('click', ()=> { autoAbort = true; });

    // --- init ---
    (async function init(){
      // determine tgid
      tgid = getTgidFromUrl();
      if(!tgid){
        // still show UI; user can set demo tgid by URL or login
        tgidEl.textContent = 'TGID: ‚Äî (add ?tgid=your_id or login)';
      } else {
        tgidEl.textContent = 'TGID: ' + tgid;
      }
      // initial grid
      renderGrid(genGrid());
      // refresh balance from server if possible
      await refreshBalanceUI();
    })();

    // expose for debug
    window.__candy = { refreshBalanceUI, singleSpin, genGrid };
  })();
  </script>
</body>
</html>
